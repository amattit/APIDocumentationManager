//
//  ServiceCallController.swift
//
//
//  Created by Generated by AI
//

import Vapor
import Fluent

// MARK: - Request/Response DTOs

struct GraphQueryParams: Content {
    let maxDepth: Int?
}

struct CreateServiceCallRequest: Content {
    let sourceAPICallID: UUID
    let targetAPICallID: UUID
    let callType: String
    let description: String?
    let callParameters: [String: String]?
    let frequency: String?
}

struct UpdateServiceCallRequest: Content {
    let callType: String?
    let description: String?
    let callParameters: [String: String]?
    let frequency: String?
}

struct ServiceCallResponse: Content {
    let id: UUID
    let sourceAPICall: APICallResponse
    let targetAPICall: APICallResponse
    let callType: String
    let description: String?
    let createdAt: Date?
    let updatedAt: Date?
    
    init(_ serviceCall: ServiceCallModel, sourceAPICall: APICallResponse, targetAPICall: APICallResponse) {
        self.id = serviceCall.id!
        self.sourceAPICall = sourceAPICall
        self.targetAPICall = targetAPICall
        self.callType = serviceCall.callType
        self.description = serviceCall.description
        self.createdAt = serviceCall.createdAt
        self.updatedAt = serviceCall.updatedAt
    }
}

struct APICallResponse: Content {
    let id: UUID
    let path: String
    let method: String
    let description: String
    let service: ServiceBasicResponse
    
    init(_ apiCall: APICallModel, service: ServiceBasicResponse) {
        self.id = apiCall.id!
        self.path = apiCall.path
        self.method = apiCall.method
        self.description = apiCall.description
        self.service = service
    }
}

struct ServiceBasicResponse: Content {
    let id: UUID
    let name: String
    let version: String
    let type: String
    let owner: String
    
    init(_ service: ServiceModel) {
        self.id = service.id!
        self.name = service.name
        self.version = service.version
        self.type = service.type
        self.owner = service.owner
    }
}

// MARK: - Graph Models

struct GraphNode: Content {
    let id: UUID
    let type: String
    let label: String
    let data: NodeData
}

struct NodeData: Content {
    let entityId: UUID
    let entityType: String
    let details: [String: String]?
}

struct GraphEdge: Content {
    let id: UUID
    let source: UUID
    let target: UUID
    let label: String
    let data: [String: String]?
}

struct GraphResponse: Content {
    let nodes: [GraphNode]
    let edges: [GraphEdge]
    let metadata: GraphMetadata
}

struct GraphMetadata: Content {
    let totalNodes: Int
    let totalEdges: Int
    let sourceId: UUID?
    let sourceType: String?
    let depth: Int?
    let timestamp: Date
}

// MARK: - Controller

struct ServiceCallController: RouteCollection {
    func boot(routes: RoutesBuilder) throws {
        let serviceCalls = routes.grouped("service-calls")
        let services = routes.grouped("services")
        let apiCalls = routes.grouped("api-calls")
        
        // 1. Управление связями между запросами
        serviceCalls.post(use: createServiceCall)
        serviceCalls.delete(":callId", use: deleteServiceCall)
        serviceCalls.put(":callId", use: updateServiceCall)
        serviceCalls.get(use: getAllServiceCalls)
        serviceCalls.get(":callId", use: getServiceCall)
        
        // 2. Графы для сервисов
        services.get(":serviceId", "outgoing-graph", use: getOutgoingGraphForService)
        services.get(":serviceId", "incoming-graph", use: getIncomingGraphForService)
        services.get(":serviceId", "full-graph", use: getFullGraphForService)
        
        // 3. Графы для API вызовов
        apiCalls.get(":apiCallId", "outgoing-graph", use: getOutgoingGraphForAPICall)
        apiCalls.get(":apiCallId", "incoming-graph", use: getIncomingGraphForAPICall)
        apiCalls.get(":apiCallId", "full-graph", use: getFullGraphForAPICall)
    }
    
    // MARK: - 1. Создать связь между запросами сервисов
    func createServiceCall(req: Request) async throws -> ServiceCallResponse {
        let createRequest = try req.content.decode(CreateServiceCallRequest.self)
        
        // Проверяем существование source API call
        guard let sourceAPICall = try await APICallModel.find(createRequest.sourceAPICallID, on: req.db) else {
            throw Abort(.notFound, reason: "Source API call not found")
        }
        
        // Проверяем существование target API call
        guard let targetAPICall = try await APICallModel.find(createRequest.targetAPICallID, on: req.db) else {
            throw Abort(.notFound, reason: "Target API call not found")
        }
        
        // Проверяем, не создает ли сервис связь сам с собой
        if createRequest.sourceAPICallID == createRequest.targetAPICallID {
            throw Abort(.badRequest, reason: "Cannot create a service call to itself")
        }
        
        // Проверяем, не существует ли уже такая связь
        let existingCall = try await ServiceCallModel.query(on: req.db)
            .filter(\.$sourceAPICall.$id == createRequest.sourceAPICallID)
            .filter(\.$targetAPICall.$id == createRequest.targetAPICallID)
            .first()
        
        if existingCall != nil {
            throw Abort(.conflict, reason: "Service call already exists")
        }
        
        // Создаем новую связь
        let serviceCall = ServiceCallModel(
            sourceAPICallID: createRequest.sourceAPICallID,
            targetAPICallID: createRequest.targetAPICallID,
            callType: createRequest.callType,
            description: createRequest.description,
            callParameters: createRequest.callParameters,
            frequency: createRequest.frequency
        )
        
        try await serviceCall.save(on: req.db)
        
        // Загружаем связанные данные для ответа
        try await sourceAPICall.$service.load(on: req.db)
        try await targetAPICall.$service.load(on: req.db)
        
        let sourceResponse = APICallResponse(sourceAPICall, service: ServiceBasicResponse(sourceAPICall.service))
        let targetResponse = APICallResponse(targetAPICall, service: ServiceBasicResponse(targetAPICall.service))
        
        return ServiceCallResponse(serviceCall, sourceAPICall: sourceResponse, targetAPICall: targetResponse)
    }
    
    // MARK: - 2. Удалить связь между запросами сервисов
    func deleteServiceCall(req: Request) async throws -> HTTPStatus {
        guard let callId = req.parameters.get("callId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid call ID")
        }
        
        guard let serviceCall = try await ServiceCallModel.find(callId, on: req.db) else {
            throw Abort(.notFound, reason: "Service call not found")
        }
        
        try await serviceCall.delete(on: req.db)
        
        return .noContent
    }
    
    // MARK: - Вспомогательные CRUD методы
    
    func updateServiceCall(req: Request) async throws -> ServiceCallResponse {
        guard let callId = req.parameters.get("callId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid call ID")
        }
        
        guard let serviceCall = try await ServiceCallModel.find(callId, on: req.db) else {
            throw Abort(.notFound, reason: "Service call not found")
        }
        
        let updateRequest = try req.content.decode(UpdateServiceCallRequest.self)
        
        if let callType = updateRequest.callType {
            serviceCall.callType = callType
        }
        
        serviceCall.description = updateRequest.description
        
        try await serviceCall.save(on: req.db)
        
        // Загружаем связанные данные для ответа
        try await serviceCall.$sourceAPICall.load(on: req.db)
        try await serviceCall.$targetAPICall.load(on: req.db)
        try await serviceCall.sourceAPICall.$service.load(on: req.db)
        try await serviceCall.targetAPICall.$service.load(on: req.db)
        
        let sourceResponse = APICallResponse(
            serviceCall.sourceAPICall,
            service: ServiceBasicResponse(serviceCall.sourceAPICall.service)
        )
        let targetResponse = APICallResponse(
            serviceCall.targetAPICall,
            service: ServiceBasicResponse(serviceCall.targetAPICall.service)
        )
        
        return ServiceCallResponse(serviceCall, sourceAPICall: sourceResponse, targetAPICall: targetResponse)
    }
    
    func getAllServiceCalls(req: Request) async throws -> [ServiceCallResponse] {
        let serviceCalls = try await ServiceCallModel.query(on: req.db)
            .with(\.$sourceAPICall) { source in
                source.with(\.$service)
            }
            .with(\.$targetAPICall) { target in
                target.with(\.$service)
            }
            .all()
        
        return try serviceCalls.map { serviceCall in
            let sourceResponse = APICallResponse(
                serviceCall.sourceAPICall,
                service: ServiceBasicResponse(serviceCall.sourceAPICall.service)
            )
            let targetResponse = APICallResponse(
                serviceCall.targetAPICall,
                service: ServiceBasicResponse(serviceCall.targetAPICall.service)
            )
            return ServiceCallResponse(serviceCall, sourceAPICall: sourceResponse, targetAPICall: targetResponse)
        }
    }
    
    func getServiceCall(req: Request) async throws -> ServiceCallResponse {
        guard let callId = req.parameters.get("callId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid call ID")
        }
        
        guard let serviceCall = try await ServiceCallModel.find(callId, on: req.db) else {
            throw Abort(.notFound, reason: "Service call not found")
        }
        
        try await serviceCall.$sourceAPICall.load(on: req.db)
        try await serviceCall.$targetAPICall.load(on: req.db)
        try await serviceCall.sourceAPICall.$service.load(on: req.db)
        try await serviceCall.targetAPICall.$service.load(on: req.db)
        
        let sourceResponse = APICallResponse(
            serviceCall.sourceAPICall,
            service: ServiceBasicResponse(serviceCall.sourceAPICall.service)
        )
        let targetResponse = APICallResponse(
            serviceCall.targetAPICall,
            service: ServiceBasicResponse(serviceCall.targetAPICall.service)
        )
        
        return ServiceCallResponse(serviceCall, sourceAPICall: sourceResponse, targetAPICall: targetResponse)
    }
    
    // MARK: - 3. Построить граф запросов ОТ сервиса (исходящие вызовы)
    func getOutgoingGraphForService(req: Request) async throws -> GraphResponse {
        guard let serviceId = req.parameters.get("serviceId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid service ID")
        }
        
        let queryParams = try? req.query.decode(GraphQueryParams.self)
        let maxDepth = queryParams?.maxDepth ?? 3
        
        guard let service = try await ServiceModel.find(serviceId, on: req.db) else {
            throw Abort(.notFound, reason: "Service not found")
        }
        
        // Получаем все API вызовы сервиса
        let apiCalls = try await service.$apiCalls.get(on: req.db)
        
        var allNodes: [UUID: GraphNode] = [:]
        var allEdges: [GraphEdge] = []
        
        // Добавляем исходный сервис как узел
        let serviceNode = createServiceNode(service)
        allNodes[serviceNode.id] = serviceNode
        
        // Для каждого API вызова сервиса строим исходящий граф
        for apiCall in apiCalls {
            let (nodes, edges) = try await buildOutgoingGraph(
                from: apiCall,
                currentDepth: 0,
                maxDepth: maxDepth,
                visited: [:],
                req: req
            )
            
            // Добавляем узел для самого API вызова
            let apiCallNode = createAPICallNode(apiCall, service: service)
            allNodes[apiCallNode.id] = apiCallNode
            
            // Добавляем связь между сервисом и его API вызовом
            let serviceToAPICallEdge = GraphEdge(
                id: UUID(),
                source: serviceNode.id,
                target: apiCallNode.id,
                label: "contains",
                data: ["relationship": "service_to_apicall"]
            )
            allEdges.append(serviceToAPICallEdge)
            
            // Добавляем собранные узлы и ребра
            for (id, node) in nodes {
                allNodes[id] = node
            }
            allEdges.append(contentsOf: edges)
        }
        
        return createGraphResponse(
            nodes: Array(allNodes.values),
            edges: allEdges,
            sourceId: serviceId,
            sourceType: "service",
            depth: maxDepth
        )
    }
    
    // MARK: - 4. Построить граф запросов К сервису (входящие вызовы)
    func getIncomingGraphForService(req: Request) async throws -> GraphResponse {
        guard let serviceId = req.parameters.get("serviceId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid service ID")
        }
        
        let queryParams = try? req.query.decode(GraphQueryParams.self)
        let maxDepth = queryParams?.maxDepth ?? 3
        
        guard let service = try await ServiceModel.find(serviceId, on: req.db) else {
            throw Abort(.notFound, reason: "Service not found")
        }
        
        var allNodes: [UUID: GraphNode] = [:]
        var allEdges: [GraphEdge] = []
        
        // Добавляем целевой сервис как узел
        let serviceNode = createServiceNode(service)
        allNodes[serviceNode.id] = serviceNode
        
        // Получаем все входящие вызовы к API этого сервиса
        let apiCalls = try await service.$apiCalls.get(on: req.db)
        
        for apiCall in apiCalls {
            let (nodes, edges) = try await buildIncomingGraph(
                to: apiCall,
                currentDepth: 0,
                maxDepth: maxDepth,
                visited: [:],
                req: req
            )
            
            // Добавляем узел для API вызова
            let apiCallNode = createAPICallNode(apiCall, service: service)
            allNodes[apiCallNode.id] = apiCallNode
            
            // Добавляем связь между API вызовом и сервисом
            let apiCallToServiceEdge = GraphEdge(
                id: UUID(),
                source: apiCallNode.id,
                target: serviceNode.id,
                label: "belongs_to",
                data: ["relationship": "apicall_to_service"]
            )
            allEdges.append(apiCallToServiceEdge)
            
            // Добавляем собранные узлы и ребра
            for (id, node) in nodes {
                allNodes[id] = node
            }
            allEdges.append(contentsOf: edges)
        }
        
        return createGraphResponse(
            nodes: Array(allNodes.values),
            edges: allEdges,
            sourceId: serviceId,
            sourceType: "service",
            depth: maxDepth
        )
    }
    
    // MARK: - 5. Построить граф запросов ОТ запроса (исходящие вызовы)
    func getOutgoingGraphForAPICall(req: Request) async throws -> GraphResponse {
        guard let apiCallId = req.parameters.get("apiCallId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid API call ID")
        }
        
        let queryParams = try? req.query.decode(GraphQueryParams.self)
        let maxDepth = queryParams?.maxDepth ?? 3
        
        guard let apiCall = try await APICallModel.find(apiCallId, on: req.db) else {
            throw Abort(.notFound, reason: "API call not found")
        }
        
        try await apiCall.$service.load(on: req.db)
        
        let (nodes, edges) = try await buildOutgoingGraph(
            from: apiCall,
            currentDepth: 0,
            maxDepth: maxDepth,
            visited: [:],
            req: req
        )
        
        // Добавляем узел для исходного API вызова
        let apiCallNode = createAPICallNode(apiCall, service: apiCall.service)
        var allNodes = [apiCallNode.id: apiCallNode]
        allNodes.merge(nodes) { (_, new) in new }
        
        return createGraphResponse(
            nodes: Array(allNodes.values),
            edges: edges,
            sourceId: apiCallId,
            sourceType: "api_call",
            depth: maxDepth
        )
    }
    
    // MARK: - 6. Построить граф запросов К запросу (входящие вызовы)
    func getIncomingGraphForAPICall(req: Request) async throws -> GraphResponse {
        guard let apiCallId = req.parameters.get("apiCallId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid API call ID")
        }
        
        let queryParams = try? req.query.decode(GraphQueryParams.self)
        let maxDepth = queryParams?.maxDepth ?? 3
        
        guard let apiCall = try await APICallModel.find(apiCallId, on: req.db) else {
            throw Abort(.notFound, reason: "API call not found")
        }
        
        try await apiCall.$service.load(on: req.db)
        
        let (nodes, edges) = try await buildIncomingGraph(
            to: apiCall,
            currentDepth: 0,
            maxDepth: maxDepth,
            visited: [:],
            req: req
        )
        
        // Добавляем узел для целевого API вызова
        let apiCallNode = createAPICallNode(apiCall, service: apiCall.service)
        var allNodes = [apiCallNode.id: apiCallNode]
        allNodes.merge(nodes) { (_, new) in new }
        
        return createGraphResponse(
            nodes: Array(allNodes.values),
            edges: edges,
            sourceId: apiCallId,
            sourceType: "api_call",
            depth: maxDepth
        )
    }
    
    // MARK: - Полный граф для сервиса (исходящие + входящие)
    func getFullGraphForService(req: Request) async throws -> GraphResponse {
        let queryParams = try? req.query.decode(GraphQueryParams.self)
        let maxDepth = queryParams?.maxDepth ?? 3
        
        let outgoing = try await getOutgoingGraphForService(req: req)
        let incoming = try await getIncomingGraphForService(req: req)
        
        // Объединяем узлы и ребра
        var allNodes: [UUID: GraphNode] = [:]
        var allEdges: [GraphEdge] = []
        
        for node in outgoing.nodes {
            allNodes[node.id] = node
        }
        for node in incoming.nodes {
            allNodes[node.id] = node
        }
        
        allEdges.append(contentsOf: outgoing.edges)
        allEdges.append(contentsOf: incoming.edges)
        
        guard let serviceId = req.parameters.get("serviceId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid service ID")
        }
        
        return createGraphResponse(
            nodes: Array(allNodes.values),
            edges: allEdges,
            sourceId: serviceId,
            sourceType: "service",
            depth: maxDepth
        )
    }
    
    // MARK: - Полный граф для API вызова (исходящие + входящие)
    func getFullGraphForAPICall(req: Request) async throws -> GraphResponse {
        let queryParams = try? req.query.decode(GraphQueryParams.self)
        let maxDepth = queryParams?.maxDepth ?? 3
        
        let outgoing = try await getOutgoingGraphForAPICall(req: req)
        let incoming = try await getIncomingGraphForAPICall(req: req)
        
        // Объединяем узлы и ребра
        var allNodes: [UUID: GraphNode] = [:]
        var allEdges: [GraphEdge] = []
        
        for node in outgoing.nodes {
            allNodes[node.id] = node
        }
        for node in incoming.nodes {
            allNodes[node.id] = node
        }
        
        allEdges.append(contentsOf: outgoing.edges)
        allEdges.append(contentsOf: incoming.edges)
        
        guard let apiCallId = req.parameters.get("apiCallId", as: UUID.self) else {
            throw Abort(.badRequest, reason: "Invalid API call ID")
        }
        
        return createGraphResponse(
            nodes: Array(allNodes.values),
            edges: allEdges,
            sourceId: apiCallId,
            sourceType: "api_call",
            depth: maxDepth
        )
    }
    
    // MARK: - Вспомогательные методы для построения графов
    
    private func buildOutgoingGraph(
        from apiCall: APICallModel,
        currentDepth: Int,
        maxDepth: Int,
        visited: [UUID: Int],
        req: Request
    ) async throws -> ([UUID: GraphNode], [GraphEdge]) {
        guard currentDepth < maxDepth else {
            return ([:], [])
        }
        
        var nodes: [UUID: GraphNode] = [:]
        var edges: [GraphEdge] = []
        var newVisited = visited
        
        // Помечаем текущий узел как посещенный на текущей глубине
        newVisited[apiCall.id!] = currentDepth
        
        // Получаем все исходящие вызовы из этого API вызова
        let serviceCalls = try await ServiceCallModel.query(on: req.db)
            .filter(\.$sourceAPICall.$id == apiCall.id!)
            .with(\.$targetAPICall) { target in
                target.with(\.$service)
            }
            .all()
        
        for serviceCall in serviceCalls {
            let targetAPICall = serviceCall.targetAPICall
            let targetService = targetAPICall.service
            
            // Создаем узлы для целевого API вызова и сервиса
            let targetAPICallNode = createAPICallNode(targetAPICall, service: targetService)
            let targetServiceNode = createServiceNode(targetService)
            
            nodes[targetAPICallNode.id] = targetAPICallNode
            nodes[targetServiceNode.id] = targetServiceNode
            
            // Создаем ребро для связи между API вызовами
            let edge = GraphEdge(
                id: serviceCall.id!,
                source: apiCall.id!,
                target: targetAPICall.id!,
                label: serviceCall.callType,
                data: [
                    "description": serviceCall.description ?? "",
                    "relationship": "api_call_to_api_call"
                ]
            )
            edges.append(edge)
            
            // Создаем ребро для связи между API вызовом и его сервисом
            let serviceEdge = GraphEdge(
                id: UUID(),
                source: targetAPICall.id!,
                target: targetService.id!,
                label: "belongs_to",
                data: ["relationship": "apicall_to_service"]
            )
            edges.append(serviceEdge)
            
            // Рекурсивно строим граф для целевого API вызова, если не посещали или посещали на большей глубине
            if let visitedDepth = newVisited[targetAPICall.id!] {
                if currentDepth + 1 < visitedDepth {
                    let (childNodes, childEdges) = try await buildOutgoingGraph(
                        from: targetAPICall,
                        currentDepth: currentDepth + 1,
                        maxDepth: maxDepth,
                        visited: newVisited,
                        req: req
                    )
                    
                    nodes.merge(childNodes) { (_, new) in new }
                    edges.append(contentsOf: childEdges)
                }
            } else {
                let (childNodes, childEdges) = try await buildOutgoingGraph(
                    from: targetAPICall,
                    currentDepth: currentDepth + 1,
                    maxDepth: maxDepth,
                    visited: newVisited,
                    req: req
                )
                
                nodes.merge(childNodes) { (_, new) in new }
                edges.append(contentsOf: childEdges)
            }
        }
        
        return (nodes, edges)
    }
    
    private func buildIncomingGraph(
        to apiCall: APICallModel,
        currentDepth: Int,
        maxDepth: Int,
        visited: [UUID: Int],
        req: Request
    ) async throws -> ([UUID: GraphNode], [GraphEdge]) {
        guard currentDepth < maxDepth else {
            return ([:], [])
        }
        
        var nodes: [UUID: GraphNode] = [:]
        var edges: [GraphEdge] = []
        var newVisited = visited
        
        // Помечаем текущий узел как посещенный на текущей глубине
        newVisited[apiCall.id!] = currentDepth
        
        // Получаем все входящие вызовы к этому API вызову
        let serviceCalls = try await ServiceCallModel.query(on: req.db)
            .filter(\.$targetAPICall.$id == apiCall.id!)
            .with(\.$sourceAPICall) { source in
                source.with(\.$service)
            }
            .all()
        
        for serviceCall in serviceCalls {
            let sourceAPICall = serviceCall.sourceAPICall
            let sourceService = sourceAPICall.service
            
            // Создаем узлы для исходного API вызова и сервиса
            let sourceAPICallNode = createAPICallNode(sourceAPICall, service: sourceService)
            let sourceServiceNode = createServiceNode(sourceService)
            
            nodes[sourceAPICallNode.id] = sourceAPICallNode
            nodes[sourceServiceNode.id] = sourceServiceNode
            
            // Создаем ребро для связи между API вызовами
            let edge = GraphEdge(
                id: serviceCall.id!,
                source: sourceAPICall.id!,
                target: apiCall.id!,
                label: serviceCall.callType,
                data: [
                    "description": serviceCall.description ?? "",
                    "relationship": "api_call_to_api_call"
                ]
            )
            edges.append(edge)
            
            // Создаем ребро для связи между API вызовом и его сервисом
            let serviceEdge = GraphEdge(
                id: UUID(),
                source: sourceAPICall.id!,
                target: sourceService.id!,
                label: "belongs_to",
                data: ["relationship": "apicall_to_service"]
            )
            edges.append(serviceEdge)
            
            // Рекурсивно строим граф для исходного API вызова, если не посещали или посещали на большей глубине
            if let visitedDepth = newVisited[sourceAPICall.id!] {
                if currentDepth + 1 < visitedDepth {
                    let (childNodes, childEdges) = try await buildIncomingGraph(
                        to: sourceAPICall,
                        currentDepth: currentDepth + 1,
                        maxDepth: maxDepth,
                        visited: newVisited,
                        req: req
                    )
                    
                    nodes.merge(childNodes) { (_, new) in new }
                    edges.append(contentsOf: childEdges)
                }
            } else {
                let (childNodes, childEdges) = try await buildIncomingGraph(
                    to: sourceAPICall,
                    currentDepth: currentDepth + 1,
                    maxDepth: maxDepth,
                    visited: newVisited,
                    req: req
                )
                
                nodes.merge(childNodes) { (_, new) in new }
                edges.append(contentsOf: childEdges)
            }
        }
        
        return (nodes, edges)
    }
    
    // MARK: - Вспомогательные методы для создания узлов
    
    private func createServiceNode(_ service: ServiceModel) -> GraphNode {
        return GraphNode(
            id: UUID(uuidString: "service-\(service.id!.uuidString)") ?? UUID(),
            type: "service",
            label: "\(service.name) v\(service.version)",
            data: NodeData(
                entityId: service.id!,
                entityType: "service",
                details: [
                    "name": service.name,
                    "version": service.version,
                    "type": service.type,
                    "owner": service.owner,
                    "description": service.description ?? ""
                ]
            )
        )
    }
    
    private func createAPICallNode(_ apiCall: APICallModel, service: ServiceModel) -> GraphNode {
        return GraphNode(
            id: UUID(uuidString: "apicall-\(apiCall.id!.uuidString)") ?? UUID(),
            type: "api_call",
            label: "\(apiCall.method) \(apiCall.path)",
            data: NodeData(
                entityId: apiCall.id!,
                entityType: "api_call",
                details: [
                    "method": apiCall.method,
                    "path": apiCall.path,
                    "description": apiCall.description,
                    "service_name": service.name,
                    "tags": apiCall.tags.joined(separator: ", ")
                ]
            )
        )
    }
    
    private func createGraphResponse(
        nodes: [GraphNode],
        edges: [GraphEdge],
        sourceId: UUID,
        sourceType: String,
        depth: Int
    ) -> GraphResponse {
        return GraphResponse(
            nodes: nodes,
            edges: edges,
            metadata: GraphMetadata(
                totalNodes: nodes.count,
                totalEdges: edges.count,
                sourceId: sourceId,
                sourceType: sourceType,
                depth: depth,
                timestamp: Date()
            )
        )
    }
}
